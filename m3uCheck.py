import concurrent.futures
import requests
import time

# è¯»å–æ–‡ä»¶å†…å®¹
def read_txt_file(file_path):
    skip_strings = ['#genre#', '127.0.0.1', '192.168', '198.168', 'ChiSheng9', 'epg.pw', 'p3p', '/udp/', '(576p)', '(540p)', '(360p)', '(480p)', '(180p)', '(404p)', 'r.jdshipin', 'generationnexxxt', 'live.goodiptv.club', 'playtv-live.ifeng']  # å®šä¹‰éœ€è¦è·³è¿‡çš„å­—ç¬¦ä¸²æ•°ç»„['#', '@', '#genre#'] 
    required_strings = ['://']  # å®šä¹‰éœ€è¦åŒ…å«çš„å­—ç¬¦ä¸²æ•°ç»„['å¿…éœ€å­—ç¬¦1', 'å¿…éœ€å­—ç¬¦2'] 

    with open(file_path, 'r', encoding='utf-8') as file:
        lines = [
            line for line in file
            if not any(skip_str in line for skip_str in skip_strings) and all(req_str in line for req_str in required_strings)
        ]
    return lines

def read_txt(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        return f.readlines()

def append_to_file(filename, lines):
    with open(filename, 'a', encoding='utf-8') as f:
        for line in lines:
            f.write(line)
            
# æ ¼å¼åŒ–é¢‘é“åç§°
def process_name_string(input_str):
    parts = input_str.split(',')
    processed_parts = []
    for part in parts:
        processed_part = process_part(part)
        processed_parts.append(processed_part)
    result_str = ','.join(processed_parts)
    return result_str

def process_part(part_str):
    # å¤„ç†é€»è¾‘
    part_str = part_str.replace("ã€ŒIPV6ã€", "")  # å‰”é™¤ ã€ŒIPV6ã€
    part_str = part_str.replace("IPV6", "")  # å‰”é™¤ IPV6
    part_str = part_str.replace("ã€ŒIPV4ã€", "")  # å‰”é™¤ ã€ŒIPV4ã€
    part_str = part_str.replace("IPV4", "")  # å‰”é™¤ IPV4 
    part_str = part_str.replace("[V4]", "")  # å‰”é™¤ [V4]
    part_str = part_str.replace("[V6]", "")  # å‰”é™¤ [V6]
    part_str = part_str.replace("å°,http", ",http")  # æ›¿æ¢ å°
    part_str = part_str.replace("é«˜æ¸…,http", ",http")  # æ›¿æ¢ é«˜æ¸…
    part_str = part_str.replace("æ ‡æ¸…,http", ",http")  # æ›¿æ¢ æ ‡æ¸…  
    part_str = part_str.replace("è¦–", "è§†")  # æ›¿æ¢
    part_str = part_str.replace("è", "é—»")  # æ›¿æ¢
    part_str = part_str.replace("è¡›", "å«")  # æ›¿æ¢
    part_str = part_str.replace("æ±", "ä¸œ")  # æ›¿æ¢
    part_str = part_str.replace("è¯", "å")  # æ›¿æ¢
    part_str = part_str.replace("é›»", "ç”µ")  # æ›¿æ¢
    part_str = part_str.replace("èª", "è¯­")  # æ›¿æ¢
    part_str = part_str.replace("é–“", "é—´")  # æ›¿æ¢
    part_str = part_str.replace("äº", "äºš")  # æ›¿æ¢
    part_str = part_str.replace("ç·š", "çº¿")  # æ›¿æ¢
    part_str = part_str.replace("åœ‹", "å›½")  # æ›¿æ¢
    part_str = part_str.replace("ç£", "æ¹¾")  # æ›¿æ¢
    part_str = part_str.replace("ç’°", "ç¯")  # æ›¿æ¢
    part_str = part_str.replace("è“®", "è²")  # æ›¿æ¢
    part_str = part_str.replace("é¡", "é•œ")  # æ›¿æ¢
    part_str = part_str.replace("è²¡ç¶“", "è´¢ç»")  # æ›¿æ¢
    part_str = part_str.replace("å‡¤å‡°-", "å‡¤å‡°")  # æ›¿æ¢
    part_str = part_str.replace("é³³å‡°", "å‡¤å‡°")  # æ›¿æ¢
    part_str = part_str.replace("è³‡è¨Š", "èµ„è®¯")  # æ›¿æ¢
    part_str = part_str.replace("ç´€å¯¦", "çºªå®")  # æ›¿æ¢
    part_str = part_str.replace(" HD", "")  # å‰”é™¤ HD
    part_str = part_str.replace("HD", "")  # å‰”é™¤ HD
    part_str = part_str.replace("ğŸ˜", "0")  # æ›¿æ¢ ğŸ˜
    part_str = part_str.replace("ğŸ™", "1")  # æ›¿æ¢ ğŸ™
    part_str = part_str.replace("ğŸš", "2")  # æ›¿æ¢ ğŸš
    part_str = part_str.replace("ğŸ›", "3")  # æ›¿æ¢ ğŸ›
    part_str = part_str.replace("ğŸœ", "4")  # æ›¿æ¢ ğŸœ
    part_str = part_str.replace("ğŸ", "5")  # æ›¿æ¢ ğŸ
    part_str = part_str.replace("ğŸ", "6")  # æ›¿æ¢ ğŸ
    part_str = part_str.replace("ğŸŸ", "7")  # æ›¿æ¢ ğŸŸ
    part_str = part_str.replace("ğŸ ", "8")  # æ›¿æ¢ ğŸ 
    part_str = part_str.replace("ğŸ¡", "9")  # æ›¿æ¢ ğŸ¡
    part_str = part_str.replace("ç§»åŠ¨å’ªå’•ç›´æ’­", "å’ªå’•ä½“è‚²")  # æ›¿æ¢ ç§»åŠ¨å’ªå’•ç›´æ’­
    part_str = part_str.replace("å’ªå’•ç›´æ’­", "å’ªå’•ä½“è‚²")  # æ›¿æ¢ å’ªå’•ç›´æ’­
    part_str = part_str.replace("å’ªå’•è§†é¢‘", "å’ªå’•ä½“è‚²")  # æ›¿æ¢ å’ªå’•è§†é¢‘
    part_str = part_str.replace("å’ªå’•ä½“è‚²-", "å’ªå’•ä½“è‚²")  # æ›¿æ¢ å’ªå’•ä½“è‚²
    part_str = part_str.replace("å’ªå’•ä½“è‚²_", "å’ªå’•ä½“è‚²")  # æ›¿æ¢ å’ªå’•ä½“è‚²
    part_str = part_str.replace("â€¢", "")  # å…ˆå‰”é™¤ â€¢  
    part_str = part_str.replace("_4M1080HEVC", "")  # å‰”é™¤
    part_str = part_str.replace("_2.5M1080HEVC", "")  # å‰”é™¤
    part_str = part_str.replace(" (1080p)", "")  # æ›¿æ¢ 1080p
    part_str = part_str.replace(" (900p)", "")  # æ›¿æ¢ 900p
    part_str = part_str.replace(" (720p)", "")  # æ›¿æ¢ 720p
    part_str = part_str.replace(" (576p)", "")  # æ›¿æ¢ 576p
    part_str = part_str.replace(" (540p)", "")  # æ›¿æ¢ 540p
    part_str = part_str.replace(" (480p)", "")  # æ›¿æ¢ 480p
    part_str = part_str.replace(" (360p)", "")  # æ›¿æ¢ 360p
    part_str = part_str.replace(" (240p)", "")  # æ›¿æ¢ 240p
    part_str = part_str.replace(" (180p)", "")  # æ›¿æ¢ 180p
    part_str = part_str.replace("  [Geo-blocked]", "")  # æ›¿æ¢[Geo-blocked]
    
    if "CCTV" in part_str and "://" not in part_str:
        part_str = part_str.replace("PLUS", "+")  # æ›¿æ¢ PLUS
        part_str = part_str.replace("1080", "")  # æ›¿æ¢ 1080
        filtered_str = ''.join(char for char in part_str if char.isdigit() or char == 'K' or char == '+')
        if not filtered_str.strip():  # å¤„ç†ç‰¹æ®Šæƒ…å†µï¼Œå¦‚æœå‘ç°æ²¡æœ‰æ‰¾åˆ°é¢‘é“æ•°å­—è¿”å›åŸåç§°
            filtered_str = part_str.replace("CCTV", "")
        if len(filtered_str) > 2 and re.search(r'4K|8K', filtered_str):  # ç‰¹æ®Šå¤„ç†CCTVä¸­éƒ¨åˆ†4Kå’Œ8Kåç§°
            # ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ›¿æ¢ï¼Œåˆ é™¤4Kæˆ–8Kåé¢çš„å­—ç¬¦ï¼Œå¹¶ä¸”ä¿ç•™4Kæˆ–8K
            filtered_str = re.sub(r'(4K|8K).*', r'\1', filtered_str)
            if len(filtered_str) > 2: 
                # ç»™4Kæˆ–8Kæ·»åŠ æ‹¬å·
                filtered_str = re.sub(r'(4K|8K)', r'(\1)', filtered_str)
        return "CCTV" + filtered_str 
    elif "å«è§†" in part_str:
        part_str = part_str.replace("-å«è§†", "å«è§†")  # æ›¿æ¢ -å«è§†
        # å®šä¹‰æ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼ï¼ŒåŒ¹é…â€œå«è§†â€åé¢çš„å†…å®¹
        pattern = r'å«è§†ã€Œ.*ã€'
        # ä½¿ç”¨subå‡½æ•°æ›¿æ¢åŒ¹é…çš„å†…å®¹ä¸ºç©ºå­—ç¬¦ä¸²
        result_str = re.sub(pattern, 'å«è§†', part_str)
        return result_str
    return part_str

def filter_and_save_channel_names(input_file):
    with open(input_file, 'r', encoding='utf-8') as file:
        lines = file.readlines()
    
    processed_lines = []
    for line in lines:
        if ',' in line:
            channel_name, url = line.split(',', 1)
            processed_channel_name = process_name_string(channel_name)
            processed_line = f"{processed_channel_name},{url}"
            processed_lines.append(processed_line)
        else:
            processed_lines.append(line)
    
    with open(input_file, 'w', encoding='utf-8') as out_file:
        for line in processed_lines:
            out_file.write(line)

# æ£€æµ‹å•ä¸ªURLçš„å“åº”æ—¶é—´
def check_url(url):
    try:
        start_time = time.time()
        response = requests.get(url, timeout=2)
        end_time = time.time()
        if response.status_code == 200:
            return url, end_time - start_time
    except requests.RequestException:
        return url, None
    return url, None

# å¤šçº¿ç¨‹æ£€æµ‹URL
def detect_urls(urls):
    results = []
    with concurrent.futures.ThreadPoolExecutor() as executor:
        future_to_url = {executor.submit(check_url, url): url for url in urls}
        for future in concurrent.futures.as_completed(future_to_url):
            url = future_to_url[future]
            try:
                url, response_time = future.result()
                if response_time is not None:
                    results.append((url, response_time))
            except Exception as e:
                print(f"URL {url} generated an exception: {e}")
    return results

# å°†å“åº”é€Ÿåº¦æœ€å¿«çš„URLå†™å…¥æ–‡ä»¶
def write_best_url(results, file_path):
    if results:
        best_url, best_time = min(results, key=lambda x: x[1])
        with open(file_path, 'w') as file:
            file.write(best_url + '\n')
        print(f"Best URL: {best_url} with response time: {best_time} seconds")
    else:
        print("No valid URL found.")

# ä¸»å‡½æ•°
def main():
    iptv_file = 'iptv.txt'
    filter_and_save_channel_names(iptv_file)
    urls = read_txt_file('iptv.txt')
        
    results = detect_urls(urls)
    write_best_url(results, 'others.txt')

if __name__ == "__main__":
    main()
